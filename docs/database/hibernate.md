# Hibernate

**Hibernate** - это фреймворк для языка программирования Java, предназначенный для решения задач объектно-реляционного отображения (ORM). 

Hibernate упрощает взаимодействие с базами данных, предоставляя объектно-ориентированный способ работы с данными в приложениях Java.

Вот основные характеристики Hibernate:
1. ORM (Object-Relational Mapping):
Hibernate предоставляет механизм отображения объектов Java на таблицы базы данных и наоборот. 
Это позволяет программистам работать с объектами в коде, а Hibernate автоматически обрабатывает сохранение, загрузку и обновление данных в базе.

2. Преимущества Hibernate:
* Простота использования: Hibernate упрощает взаимодействие с базой данных, скрывая от программиста детали работы с JDBC и SQL.
* Повышение производительности: Hibernate может кэшировать запросы и результаты запросов, что улучшает производительность и снижает количество обращений к базе данных.
* Переносимость кода: Поскольку Hibernate абстрагирует от конкретных SQL-запросов, приложение может быть легко перенесено на другую базу данных без изменения кода.
* Управление состоянием объектов: Hibernate отслеживает изменения состояния объектов и автоматически обновляет соответствующие записи в базе данных.

3. Архитектура Hibernate:
* Session Factory: Интерфейс, предоставляющий фабрику сессий Hibernate. Сессия - это объект, представляющий контекст работы с базой данных в рамках транзакции.
* Session: Интерфейс, представляющий одну транзакцию с базой данных. Сессия используется для сохранения, обновления, удаления и запросов к данным.
* Entity Class: Объектно-ориентированный класс, который отображается на таблицу базы данных. Экземпляры таких классов являются объектами с которыми работает Hibernate.
* Mapping Files: XML-файлы, определяющие отображение между сущностями в Java и таблицами в базе данных.

## JPA - Стандарт

Hibernate - Реализация JPA: Hibernate предоставляет реализацию JPA. Он предоставляет дополнительные возможности, не входящие в стандарт JPA. 
Таким образом, можно сказать, что Hibernate - это более широкий инструмент, который также поддерживает стандарт JPA.

В Hibernate **стратегии наследования (Inheritance Strategies)** используются для определения того, как объекты-наследники отображаются в базе данных. 
Hibernate поддерживает несколько стратегий наследования, которые определяют, какие таблицы будут созданы и как будут храниться данные для иерархии классов.

Вот основные стратегии наследования в Hibernate:
1. Single Table (Одна таблица):
* Описание: Все классы иерархии отображаются в одну таблицу в базе данных.
* Преимущества:
    * Простота схемы базы данных.
    * Минимизация присоединений.
* Недостатки:
    * Для классов с большим количеством полей могут быть много пустых ячеек в таблице.
    * Возможно большое количество NULL значений.
2. Table Per Class (Таблица для каждого класса):
* Описание: Каждый класс отображается в отдельную таблицу.
* Преимущества:
    * Отсутствие NULL значений и пустых ячеек.
    * Более четкая структура базы данных.
* Недостатки:
    * Возможно дублирование информации, если есть общие поля между классами.
3. Joined (Соединенные таблицы):
* Описание: Каждый класс отображается в свою собственную таблицу, а общие поля объединяются в дополнительную таблицу.
* Преимущества:
    * Более нормализованная структура базы данных.
    * Нет дублирования информации.
* Недостатки:
    * Большее количество присоединений при запросах.
    * Сложнее для понимания структуры базы данных.

## Жизненный цикл сущности (Entity Lifecycle) 

>В контексте Hibernate (и Java Persistence API - JPA) определяет стадии, через которые проходит объект при работе с базой данных. 

Жизненный цикл сущности состоит из следующих стадий:

**1. Transient (Преходящее состояние):**
* Описание: Сущность считается transient, если она только что была создана (new) и не связана с сессией Hibernate или контекстом JPA.
* Характеристики:
    * Нет соответствующей записи в базе данных.
    * Не отслеживается Hibernate.
    * Объект не управляется контекстом персистентности.
  
**2.Persistent (Состояние персистентности):**
* Описание: Сущность считается persistent, когда она ассоциирована с сессией Hibernate или контекстом JPA.
* Характеристики:
    * Существующая запись в базе данных.
    * Hibernate отслеживает изменения и автоматически синхронизирует состояние с базой данных.
  
**3. Detached (Отсоединенное состояние):**
* Описание: Сущность считается detached, когда связь с сессией Hibernate или контекстом JPA была разорвана (например, сессия была закрыта).
* Характеристики:
    * Нет связи с сессией или контекстом.
    * Изменения не автоматически синхронизируются с базой данных.
  
**4. Removed (Удаленное состояние):**
* Описание: Сущность считается removed, когда она была удалена из базы данных.
* Характеристики:
    * Запись в базе данных удалена.
    * Объект больше не управляется сессией или контекстом.
   
**Замечания:**

* Переходы между состояниями:
    * Состояние transient может стать persistent при сохранении (persist) или сохранении и обновлении (merge).
    * Состояние persistent становится detached при закрытии сессии.
    * Состояние detached может стать persistent при снова присоединении к сессии (reattach).
    * Состояние persistent становится removed при удалении.
* Методы, влияющие на жизненный цикл:
    * persist(entity): Переводит сущность в persistent состояние.
    * merge(entity): Переводит сущность в persistent состояние, если она отсоединена, или выполняет копирование, если transient.
    * remove(entity): Переводит сущность в removed состояние.
    * detach(entity): Отсоединяет сущность от сессии (переводит в detached).

## Кэширование в Hibernate

>Это механизм, предназначенный для улучшения производительности при работе с базой данных. Hibernate предоставляет различные уровни кэширования, которые позволяют хранить и использовать ранее загруженные данные, минимизируя количество запросов к базе данных.

В Hibernate существует **два основных уровня кэширования**:

**Уровень Кэширования Объектов (Object-Level Caching):**

   Этот уровень кэширования относится к кэшированию отдельных объектов, загруженных из базы данных.

* Концепция:
    * Когда объект загружается из базы данных, он сохраняется в кэше.
    * Если приложение запросит тот же объект с тем же идентификатором, Hibernate сначала проверит, есть ли он в кэше.
    * Если объект уже находится в кэше, Hibernate вернет его из кэша, избегая запроса к базе данных.
* Настройка:
    * Определяется в XML-конфигурации или аннотациях сущности с использованием атрибута @Cache.

**Уровень Кэширования Запросов (Query-Level Caching):**

   Этот уровень кэширования относится к кэшированию результатов запросов к базе данных.

* Концепция:
    * Результаты выполненных запросов к базе данных кэшируются.
    * При следующем выполнении того же запроса Hibernate проверяет кэш.
    * Если результат уже есть в кэше, Hibernate возвращает его, избегая повторного выполнения запроса.
* Настройка:
    * Определяется для конкретного запроса с использованием метода setCacheable(true).

**2. Вторичный Уровень Кэширования (Second Level Caching):**

Вторичный уровень кэширования (Second Level Caching) относится к кэшированию, которое применяется к нескольким сессиям Hibernate в рамках приложения. 
Он работает на уровне сессий и обеспечивает кэширование между различными сессиями.

## Проблема N+1 в контексте Hibernate

Проблема N+1 (N+1 Issue) — это типичная проблема в системах, использующих объектно-реляционное отображение (ORM), такое как Hibernate, при доступе к данным из базы данных. 
Проблема заключается в том, что при получении коллекции объектов, таких как список сущностей, к каждой из них выполняется дополнительный запрос, что может привести к избыточному числу запросов к базе данных.

Решение:

* **Использование JOIN FETCH:** Одним из способов решения проблемы N+1 является использование JOIN FETCH в запросе для жадной загрузки связанных коллекций. Это позволяет получить все данные в одном запросе:
* **Использование @BatchSize:** Другим способом является использование аннотации @BatchSize для настройки размера пакета (batch size), определяющего, сколько объектов должно быть загружено за один запрос:
