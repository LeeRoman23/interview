# Объектно-ориентированное программирование

ООП - это вид программирования, при котором программа строится на классах и
экземлярах этих классов, называемых объектами

Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.

### Основные принципы ООП

1. **Наследование**
    Функциональность, которая позволяет создавать новый класс, на основе уже существующего. При этом 
    поля и методы класса-предка становятся доступны и классам-наследникам. Данный принцип используется для уменьшения
    дублированности кода.
2. **Полиморфизм**
    Функциональность, которая позволяет нам использовать объекты с одинаковым интерфейсом без информации
    о внутреннем устройстве объекта. Одной из форм полиморфизма в Java является переопределение метода, когда различные формы поведения определяются объектом из которого данный метод был вызван. 
    Другой формой полиморфизма является перегрузка метода, когда его поведение определяется набором передаваемых в метод аргументов.
3. **Инкапсуляция** 
    Фунциональность, которая подразумевает сокрытие полей внутри объекта с целью защиты данных от внешнего, бесконтрольного изменения со стороны других объектов. 
    Доступ к данным (полям) предоставляется посредством публичных методов (геттеров/сеттеров). Это защитный барьер позволяет хранить информацию в безопасности внутри объекта.
4. **Абстракция**
    Функциональность, которая позволяет нам скрыть детали реализации и сосредоточиться только на самых важных вещах.
    То есть абстракции - это шаблоны, для создания новых объектов.

### IS-A, HAS-A

1. IS-A (является):

_"IS-A"_ означает отношение наследования между классами.
Например, если у тебя есть класс "Птица", и у тебя есть еще один класс "Орел", то можно сказать, что "Орел IS-A Птица". 
То есть, класс "Орел" является подтипом (или наследником) класса "Птица".
Это отражает иерархию классов, где подклассы наследуют свойства и методы от родительских классов.

2. HAS-A (имеет):

_"HAS-A"_ означает композицию или ассоциацию между классами.
Например, если у тебя есть класс "Автомобиль" и класс "Двигатель", то можно сказать, что "Автомобиль HAS-A Двигатель". 
Это означает, что объект класса "Автомобиль" содержит (или имеет) объект класса "Двигатель".
Вместо наследования, где один класс является подтипом другого, здесь у нас есть объекты одного класса, которые включены в другой класс.


### Object

**Объект** - это экземляр класса. То есть некая конструкция, которая содержит поля и методы, существующие в классе.
Класс Object является базовым классом для всех существующих и созданных классов в Java.

*Основные методы класса Object*

1. **toString(): String**

Метод toString используется для представления строкового представления объекта. По умолчанию, этот метод возвращает строку, состоящую из имени класса и хеш-кода объекта.


2. **equals(Object obj): boolean**

Метод equals служит для сравнения двух объектов на равенство. По умолчанию, этот метод сравнивает ссылки на объекты, но его можно переопределить в подклассе для более конкретной проверки равенства.

3. **hashCode(): int**

Метод hashCode возвращает хеш-код объекта. Хеш-код используется в структурах данных, таких как хеш-таблицы. Переопределение этого метода часто требуется, когда переопределен метод equals.

4. **getClass(): Class<?>**

Метод getClass возвращает объект типа Class, представляющий класс объекта. Class предоставляет множество методов для получения информации о классе, например, его имя.

5. **clone(): Object**

Метод clone используется для создания поверхностной копии объекта. Для корректного использования этого метода класс должен реализовать интерфейс Cloneable и переопределить метод clone.

6. **finalize(): void**

Метод finalize вызывается сборщиком мусора перед утилизацией объекта. Обычно он переопределяется для освобождения ресурсов или выполнения других завершающих действий.

7. **notify(): void**

Метод notify используется в контексте многозадачности для уведомления одного из потоков, ожидающих на объекте, что состояние объекта может быть изменено.

8. **notifyAll(): void**

Метод notifyAll используется для уведомления всех потоков, ожидающих на объекте, что состояние объекта может быть изменено.

9. **wait(): void**

Метод wait используется для перевода потока в режим ожидания до тех пор, пока другой поток не вызовет методы notify или notifyAll для данного объекта.

10. **wait(long timeout): void**

Аналогичен методу wait(), но с добавлением таймаута, после которого поток автоматически просыпается.

11. **wait(long timeout, int nanos): void**

Аналогичен предыдущему методу, но с возможностью указания дополнительного времени в наносекундах.

> _Эти методы предоставляют базовую функциональность для всех объектов в языках, поддерживающих ООП, и они могут быть переопределены в подклассах для более конкретного поведения._

### Конструкторы

**Конструкторы** - это специальные методы, которые вызываются при создании объекта класса.

* Класс может иметь несколько конструкторов с разными параметрами, что называется перегрузкой конструкторов. Это позволяет создавать объекты с разными способами инициализации.

```java
public class MyClass {
    // Перегруженные конструкторы
    public MyClass() {
        // Конструктор без параметров
    }

    public MyClass(int value) {
        // Конструктор с параметром
    }
}
```

* Конструктор подкласса может вызывать конструктор базового класса с помощью ключевого слова **super**.

```java
public class SubClass extends BaseClass {
    public SubClass() {
        super(); // Вызов конструктора базового класса
        // код конструктора подкласса
    }
}
```

* Конструкторы используются для инициализации полей объекта. Переменные класса могут быть установлены значениями по умолчанию или переданными через параметры конструктора.

```java
public class MyClass {
    private int number;

    public MyClass(int value) {
        this.number = value; // Инициализация поля при создании объекта
    }
}
```

* Если в классе не определен конструктор, по умолчанию создается конструктор без параметров (конструктор по умолчанию).


### Интерфейсы

**Интерфейсы** в Java представляют собой абстрактные шаблоны, определяющие методы, но не предоставляющие их реализации. Вот основная информация о интерфейсах в Java:

* Классы в Java могут реализовывать (implement) интерфейсы с использованием ключевого слова implements. Один класс может реализовывать несколько интерфейсов.

```java
public class MyClass implements MyInterface {
    // Реализация абстрактного метода из интерфейса
    public void myMethod() {
        // Код реализации
    }
}
```

* Классы в Java могут реализовывать несколько интерфейсов, обеспечивая тем самым множественное наследование интерфейсов.

```java
public class MyClass implements Interface1, Interface2 {
    // Класс реализует методы обоих интерфейсов
}
```

* В интерфейсах определяются абстрактные методы, которые должны быть реализованы классами, реализующими интерфейс.

```java
public interface MyInterface {
    void abstractMethod(); // Абстрактный метод
}
```

* С Java 8 появились методы по умолчанию, которые предоставляют реализацию метода в интерфейсе. Классы, реализующие интерфейс, автоматически получают реализацию этого метода.

```java
public interface MyInterface {
    default void defaultMethod() {
        // Реализация метода по умолчанию
    }
}
```

* Интерфейсы могут использоваться как типы данных. Это позволяет создавать переменные, тип которых является интерфейсом, и присваивать им объекты классов, реализующих этот интерфейс.

```java
MyInterface obj = new MyClass(); // MyClass реализует MyInterface
```


**Анонимные интерфейсы** - это интерфейсы, которые создаются без явного объявления имени. 
Они обычно используются в ситуациях, где нужно предоставить реализацию интерфейса для единичного использования. 
Анонимные интерфейсы создаются на месте, без создания отдельного класса или интерфейса.

```java
public class Main {
    public static void main(String[] args) {
        // Анонимный интерфейс
        MyInterface myInterface = new MyInterface() {
            @Override
            public void myMethod() {
                System.out.println("Реализация метода в анонимном интерфейсе.");
            }
        };

        myInterface.myMethod(); // Вызов метода
    }
}

// Объявление интерфейса
interface MyInterface {
    void myMethod();
}
```

**Интерфейсы-маркеры** в Java представляют собой интерфейсы без методов. 
Они используются как метки для пометки классов, указывая, что эти классы обладают определенными свойствами или должны быть обработаны определенным образом.
Интерфейсы-маркеры обычно используются для обозначения специальных свойств или требований, и их наличие в классе может влиять на его поведение или обработку.

Например: интерфейсы _Serializable_, _Clonable_ и т.д.

```java
public class Main {
    public static void main(String[] args) {
        // Класс, реализующий интерфейс-маркер
        MyClass myClass = new MyClass();
        if (myClass instanceof MyMarkerInterface) {
            System.out.println("myClass является экземпляром MyMarkerInterface.");
            // Дополнительные действия для классов, реализующих интерфейс-маркер
        }
    }
}

// Интерфейс-маркер без методов
interface MyMarkerInterface {
}

// Класс, реализующий интерфейс-маркер
class MyClass implements MyMarkerInterface {
    // Реализация класса
}
```

### Абстрактные классы и интерфейсы


**Абстрактные классы и интерфейсы** - это два механизма в объектно-ориентированном программировании, используемых в Java для организации кода и реализации абстракций. 
Рассмотрим основные отличия и варианты использования каждого из них:


#### _Абстрактные классы_

**Абстрактный класс** - это класс, который может содержать абстрактные методы (методы без реализации) и конкретные методы (с реализацией).
Нельзя создать экземпляр абстрактного класса.

```java
abstract class AbstractClass {
    // Абстрактный метод (без реализации)
    abstract void abstractMethod();

    // Конкретный метод (с реализацией)
    void concreteMethod() {
        // Реализация метода
    }
}
```

> Абстрактные классы подходят, когда необходима частичная реализация и существует общая функциональность между несколькими классами.
Они могут содержать поля и конструкторы.
>Абстрактные классы в Java поддерживают одиночное наследование. Класс может наследовать только от одного абстрактного класса.


#### _Интерфейсы_

**Интерфейс** - это набор методов (без реализации), который класс обязан реализовать, если он реализует этот интерфейс.
С Java 8 интерфейсы могут содержать методы с реализацией (default и static методы).

```java
interface MyInterface {
    // Абстрактный метод (без реализации)
    void abstractMethod();

    // Default метод (с реализацией)
    default void defaultMethod() {
        // Реализация метода
    }

    // Static метод (с реализацией)
    static void staticMethod() {
        // Реализация метода
    }
}
```

> Интерфейсы используются, когда требуется обеспечить реализацию набора методов в разных классах. Класс может реализовать несколько интерфейсов.
> Интерфейсы в Java поддерживают множественное наследование. Класс может реализовать несколько интерфейсов.

**Использование** 

* Абстрактные классы
    * Когда есть общая реализация между несколькими классами.
    * Когда требуется одиночное наследование.
* Интерфейсы
    * Когда требуется обеспечить реализацию набора методов в разных классах.
    * Когда требуется множественное наследование.
    * Когда нужно обеспечить стандартный контракт для классов.
