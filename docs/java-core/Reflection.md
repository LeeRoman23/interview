# Reflection

**Reflection** в Java - это механизм, который позволяет программам анализировать и модифицировать свое собственное поведение во время выполнения. 
С помощью Reflection можно получать информацию о классах, интерфейсах, полях и методах во время выполнения, создавать новые экземпляры классов, 
вызывать методы и устанавливать значения полей, даже если они private.

Вот некоторые основные аспекты Reflection в Java:

* Class объекты: Основная точка входа в Reflection - это объекты типа Class. 
Каждый класс в Java автоматически связан с объектом Class, который предоставляет информацию о классе.

* Получение объекта Class:
```java
Class<?> myClass = MyClass.class; // Для конкретного класса
Class<?> stringClass = String.class; // Для встроенного класса
Class<?> dynamicClass = Class.forName("com.example.DynamicClass"); // Для класса по имени
```

* Получение информации о классе
```java
Class<?> myClass = MyClass.class;
String className = myClass.getName();
int modifiers = myClass.getModifiers();
Field[] fields = myClass.getDeclaredFields();
Method[] methods = myClass.getDeclaredMethods();
```

* Создание экземпляра класса
```java
Class<?> myClass = MyClass.class;
Object instance = myClass.newInstance();
```

* Вызов метода
```java
Class<?> myClass = MyClass.class;
Object instance = myClass.newInstance();
Method myMethod = myClass.getDeclaredMethod("myMethod");
myMethod.invoke(instance);
```

* Работа с полями
```java
Class<?> myClass = MyClass.class;
Object instance = myClass.newInstance();
Field myField = myClass.getDeclaredField("myField");
myField.setAccessible(true); // Если поле private
myField.set(instance, "New value");
```

* Annotation & Reflection
>Reflection позволяет получать информацию о аннотациях класса, методов или полей, а также использовать их во время выполнения.
```java
Class<?> myClass = MyClass.class;
CustomAnnotation annotation = myClass.getAnnotation(CustomAnnotation.class);
```

Где CustomAnnotation - это пользовательская аннотация, объявленная как:
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CustomAnnotation {
    // Поля и методы аннотации
}
```

### Использование reflection

**В Java существует несколько стандартных библиотек и фреймворков, которые активно используют рефлексию для своей работы. Некоторые из них включают:**

1. **Spring Framework:**

Spring является одним из самых популярных фреймворков для разработки приложений на Java. Он широко использует рефлексию для достижения инверсии управления (IoC), внедрения зависимостей (DI), а также для обработки аспектов (AOP). Например, аннотации @Autowired и @Component используют рефлексию для определения и установки зависимостей.

2. **Hibernate:**

Hibernate - это фреймворк для работы с базами данных, реализующий ORM (Object-Relational Mapping). Он использует рефлексию для анализа объектов и их отображения в структуры баз данных, а также для выполнения запросов HQL (Hibernate Query Language).

3. **JUnit:**

JUnit - это библиотека для тестирования в Java. Она использует рефлексию для исследования классов и методов, помеченных аннотациями @Test, @Before, @After, и другими, для запуска тестов.

4. **Log4j и SLF4J:**

Библиотеки логирования, такие как Log4j и SLF4J, могут использовать рефлексию для определения классов их логгеров, чтобы обеспечить информацию о точке вызова.

5. **JavaBeans API:**

JavaBeans API использует рефлексию для обеспечения интроспекции, позволяя инструментам и средам разработки динамически определять свойства, методы и события Java-классов.

6. **Jackson (библиотека для работы с JSON):**

Jackson использует рефлексию для преобразования объектов Java в формат JSON и обратно. Он анализирует структуру классов с использованием рефлексии, чтобы определить, какие поля и методы следует включить в JSON-представление объекта.


### Примечания

**При использовании рефлексии в Java есть несколько важных вещей, которые стоит учитывать:**

1. **Производительность:**
Рефлексия может быть медленной по сравнению с обычным выполнением кода, так как операции рефлексии обычно требуют дополнительных вычислительных ресурсов. Если производительность критична, следует внимательно оценить использование рефлексии и, при необходимости, рассмотреть альтернативные подходы.

2. **Безопасность на этапе компиляции:**
Рефлексия обходит проверки на этапе компиляции, что может привести к ошибкам во время выполнения, особенно если вы пытаетесь получить доступ к приватным членам класса или вызывать методы, которые не существуют. Это может сделать код менее надежным и менее понятным.

3. **SecurityManager:**
Некоторые операции рефлексии, особенно те, которые изменяют доступ к членам класса или создают новые экземпляры классов, могут быть ограничены с помощью SecurityManager. Включение SecurityManager может привести к отказу в выполнении некоторых операций рефлексии.

4. **Изменение доступа к членам класса:**
Если вы используете рефлексию для доступа к приватным или защищенным членам класса, убедитесь, что вызовы setAccessible(true) осуществляются только тогда, когда это действительно необходимо. Изменение доступа к членам класса может сделать код менее безопасным и нарушить инкапсуляцию.

5. **Сериализация:**
Некоторые библиотеки и фреймворки, такие как сериализаторы Java, могут использовать рефлексию для доступа к приватным полям объектов. Это важно учитывать при проектировании классов, особенно в контексте сериализации.

6. **Использование с осторожностью:**
Рефлексия - это мощный инструмент, и её использование следует рассматривать с осторожностью. В большинстве случаев существуют альтернативы, более безопасные и эффективные, и их следует предпочитать.

7. **Java 9 и модульная система:**
Введение модульной системы в Java 9 также внесло изменения в рефлексию. Если вы работаете с модулями, убедитесь, что ваши модули правильно настроены для доступа к необходимым пакетам через рефлексию.