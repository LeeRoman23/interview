# Stream API

**Stream API** в Java представляет собой мощный и удобный инструмент для работы с последовательностями элементов (коллекциями, массивами и другими данными). 
Stream API предоставляет декларативный способ выполнения операций над данными и облегчает параллельную обработку данных.

### Основные понятия в Stream API:

1. Stream (Поток):
    * Поток представляет собой последовательность элементов, которую можно обрабатывать с использованием функциональных операций.
2. Операции:
    * В Stream API выделяют промежуточные и терминальные операции.
      Промежуточные операции выполняются над потоком и возвращают новый поток, позволяя цепочку операций. Примеры: filter, map, sorted.
      Терминальные операции заканчивают обработку потока и возвращают результат. Примеры: forEach, collect, reduce.
3. Ленивость:
    * Потоки являются ленивыми, что означает, что операции выполняются только при необходимости, когда требуется результат.
4. Параллельность:
    * Потоки могут быть обработаны параллельно, что улучшает производительность. Для этого используется метод parallel().
5. Источники данных:
    * Потоки могут быть созданы из различных источников данных, таких как коллекции (Collection.stream()), массивы (Arrays.stream()), файлы (Files.lines()), и др.

```java Filter
List<String> words = Arrays.asList("apple", "banana", "grape", "melon");
List<String> filteredWords = words.stream()
                                  .filter(word -> word.length() > 5)
                                  .collect(Collectors.toList());

```

```java Map
List<String> words = Arrays.asList("apple", "banana", "grape", "melon");
List<Integer> wordLengths = words.stream()
                                .map(String::length)
                                .collect(Collectors.toList());
```

```java Sorting
List<String> words = Arrays.asList("apple", "banana", "grape", "melon");
List<String> sortedWords = words.stream()
                               .sorted()
                               .collect(Collectors.toList());
```

```java Reduce
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, Integer::sum);
```

```java Parallel
List<String> words = Arrays.asList("apple", "banana", "grape", "melon");
List<String> parallelFilteredWords = words.parallelStream()
                                         .filter(word -> word.length() > 5)
                                         .collect(Collectors.toList());
```

>map и flatMap - это две операции в Stream API, используемые для преобразования элементов в потоке. 
Однако у них есть различия в том, как они обрабатывают вложенные структуры данных.
**Map** возвращает новый поток, в котором каждый элемент преобразован в соответствии с функцией.
**flatMap** также применяется к каждому элементу потока, но в отличие от map, функция, переданная в flatMap, должна возвращать поток элементов, а не отдельные элементы.


## Stateful и Stateless операции

Stateful операции:

Эти операции сохраняют состояние между элементами потока.
Примеры stateful операций в Stream API включают distinct() и sorted(). 
Обе эти операции должны помнить предыдущие элементы потока, чтобы правильно работать. 
Например, чтобы убедиться, что элементы уникальны (в случае distinct()) или для правильной сортировки (в случае sorted()).

```java
List<Integer> uniqueNumbers = numbers.stream()
                                    .distinct() // stateful
                                    .collect(Collectors.toList());
```

Stateless операции:

Эти операции не сохраняют состояние между элементами потока.
Каждый элемент обрабатывается независимо от других элементов.
Примеры stateless операций включают filter(), map(), forEach() и т. д.

```java
List<String> upperCaseNames = names.stream()
                                   .map(String::toUpperCase) // stateless
                                   .collect(Collectors.toList());
```

## Stream API pipeline description

**Stream API pipeline** - это последовательность операций, которые можно выполнять над элементами потока данных с использованием Java Stream API. 
Java Stream API предоставляет удобные методы для обработки коллекций данных (например, списков или массивов) в функциональном стиле. 
Пайплайн Stream API обычно состоит из следующих этапов:

1) **Исходный поток данных**: Первый шаг в создании пайплайна - это получение исходного потока данных. 
Это может быть коллекция данных, массив, файл или другой источник данных. 
Вы можете создать поток данных с помощью метода stream() у коллекций или Arrays.stream() для массивов.

2) **Промежуточные операции (Intermediate Operations)**: Промежуточные операции выполняются над элементами потока и создают новый поток данных как результат. 
Они преобразуют, фильтруют или применяют операции к элементам, но не производят окончательных результатов.
Примеры промежуточных операций включают filter(), map(), distinct(), sorted() и другие.

3) **Терминальная операция (Terminal Operation)**: Терминальная операция завершает выполнение пайплайна и возвращает результат. 
Это может быть операция, которая собирает элементы в коллекцию, вычисляет агрегатные функции, выводит результаты или выполняет другие окончательные действия. 
Примеры терминальных операций включают collect(), forEach(), count(), reduce() и другие.

## Является ли стрим переиспользуемым?

**Нет, стримы в Java Stream API не являются переиспользуемыми.**
Однажды использованный стрим больше не может быть использован для выполнения других операций. 

Как только выполнена терминальная операция (например, collect(), forEach(), count() и так далее), стрим считается закрытым, и вы не можете продолжить работу с ним или применять к нему дополнительные промежуточные или терминальные операции.

Если вам нужно выполнить несколько различных операций над данными, вы должны создать новый стрим для каждой последующей операции. 

Обычно это делается путем вызова метода stream() на исходных данных или использования другого источника данных для создания нового стрима. 

## Начнется ли работа stream если терминальный оператор не добавлен?

**Нет, работа stream не начинается, пока не будет добавлена терминальная операция.**
В Java Stream API операции с потоком данных делятся на две основные категории: промежуточные операции и терминальные операции.

Промежуточные операции (например, filter(), map(), sorted()) являются ленивыми, что означает, что они не выполняют обработку данных до тех пор, пока не вызывается терминальная операция (например, collect(), forEach(), count()). 
Эти промежуточные операции только настраивают конвейер для обработки данных, но не запускают фактическую манипуляцию данными.